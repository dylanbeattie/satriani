program     = p:statement *
	{ return { program: p } }

comment     = '(' [^)]* ')'

_           = ((' ' / '\t')+) / comment

noise 	= (_ / [;,?!&])
EOL = 	noise* '\n'

statement   = _* s:(operation / blank_line) EOL
                { return s }

blank_line  = _* {return {blank:  ''}}

operation   = output / assignment / crement / conditional

conditional = 'if' _ e:expression _

			/ 'else'

output      = ('say'i/'shout'i/'whisper'i/'scream'i) _+ e:expression
                {return {'output': e}}

simple_expression  =   constant / lookup / literal / pronoun

literal = constant / number / string

constant = null / true / false / mysterious

true 	= ('true'i / 'ok'i / 'right'i / 'yes'i) { return { constant: true } }

false 	= ('false'i / 'lies'i / 'wrong'i / 'no'i) { return { constant: false } }

null 	= ('null'i / 'nothing'i / 'nowhere'i / 'nobody'i / 'empty'i / 'gone'i) { return { constant: null } }


mysterious = 'mysterious'
	{ return { constant: "mysterious" } }

number      = n:$('-'?[0-9]+ ('.' [0-9]+)?) '.'?
                { return {number: parseFloat(n)} }
			/
            	n:$('.' [0-9]+)
                { return {number: parseFloat(n) } }


string      = '"' s:$[^"]* '"'
                { return {string: s}}

expression = lhs:arithmetic _ c:comparator _ rhs:arithmetic
	{
    	return {
        	comparison: {
            	comparator: c,
                lhs: lhs,
                rhs: rhs
            }
        };
    }
    /
    arithmetic

greater 	= ('higher'i /'greater'i / 'bigger'i / 'stronger'i)
smaller	 	= ('lower'i /'less'i / 'smaller'i / 'weaker'i)
great	= ('high'i / 'greater'i / 'big'i / 'strong'i)
small	= ('low'i / 'small'i / 'weak'i)

comparator 	= 	'is'i _ greater _ 'than'i { return 'gt' }
    		/ 	'is'i _ smaller _ 'than'i { return 'lt' }
            /	'is'i _ 'as'i _ great _ 'as'i { return 'ge' }
            /	'is'i _ 'as'i _ small _ 'as'i { return 'le' }
			/ 	'is'i { return 'eq' }

arithmetic         = first:product rest:((add / subtract) product)+
                { return rest.reduce(function(memo, curr) {
                      return { binary: { op: curr[0], left: memo, right: curr[1]} };
                }, first); }
            / product

product     = first:simple_expression rest:((multiply / divide) simple_expression)+
                { return rest.reduce(function(memo, curr) {
                    return { binary: { op: curr[0], left: memo, right: curr[1]} };
                }, first); }
            / simple_expression

// Note that operator aliases explicitly include a trailing space,
// otherwise 'with' is a prefix code for 'without' and confuses the parser.
add 		= _* ('+' / 'plus ' / 'with ') _*       { return '+' }
subtract 	= _* ('-' / 'minus ' / 'without ') _*   { return '-' }
multiply 	= _* ('*' / 'times ' / 'of ') _*        { return '*' }
divide 		= _* ('/' / 'over ' / 'between ') _*    { return '/' }

pronoun = pronoun:(
    // Longest pronouns first to avoid prefix coding errors.
    // 4-letter pronouns
    'they'i / 'them'i
    // 3-letter pronouns
    / 'she'i / 'him'i / 'her'i / 'hir'i / 'zie'i / 'zir'i / 'xem'i / 'ver'i
    // 2-letter pronouns
    / 'ze'i / 've'i / 'xe'i / 'it'i / 'he'i
    )
    { return { pronoun: pronoun.toLowerCase() } }

lookup 	= v:variable
	{ return { lookup: { variable: v } }; }

common_prefix = ( 'an'i / 'a'i / 'the'i / 'my'i / 'your'i)
common_variable = prefix:common_prefix _+ name:$([A-Za-z]+)
				{ return (prefix + '_' + name).toLowerCase() };

assignment 	= v:variable ('\'s' / (_* ('=' / 'is 'i / 'was 'i / 'were 'i))) _* e:(literal / poetic_number)
				{ return { assign: { variable: v, expression: e} }; }
              /
              v:variable _+ 'says'i _+ e:poetic_string
              	{ return { assign: { variable: v, expression: e} }; }
              / 'put'i _+ e:expression _+ 'into'i _+ v:variable
				{ return { assign: { variable: v, expression: e} }; }

poetic_string = s:$[^\n]*
	{ return { string: s} }

poetic_number = poetic_digit_separator* n:poetic_digits poetic_digit_separator* d:poetic_decimal? poetic_digit_separator*

	{ return { number: parseFloat(d?n+'.'+d:n)}}

poetic_decimal = '.' poetic_decimal_digit_separator* d:poetic_decimal_digits poetic_decimal_digit_separator* {return d}
				/
                '.' poetic_decimal_digit_separator*

poetic_digit_separator = ( _ / [0-9\',;:?!+_\-/] )

poetic_digits =
	poetic_digit_separator* head:poetic_digit poetic_digit_separator+ tail:poetic_digits
    	{ return head + tail }
	/
    d: poetic_digit
    	{ return d }

poetic_decimal_digit_separator = ( _ / poetic_digit_separator / '.')
poetic_decimal_digits =
	poetic_decimal_digit_separator* head:poetic_digit poetic_decimal_digit_separator+ tail:poetic_decimal_digits
    	{ return head + tail }
	/
    d: poetic_digit
    	{ return d }

poetic_digit = t:[A-Za-z']+
	{ return (t.filter(c => /[A-Za-z]/.test(c)).length%10).toString()}

variable = common_variable / proper_variable / pronoun

proper_noun = [A-Z][A-Za-z]*
proper_variable = head:$(proper_noun (' ' $proper_noun)*)
	{ return head.replace(/ /g, '_').toUpperCase()  }

crement = increment / decrement

increment = 'build'i _+ v:variable _+ t:('up'i noise*)+
	{ return {
    	increment: {
        	variable: v,
            multiple: t.length
        }
    }; }

decrement = 'knock'i _+ v:variable _+ t:('down'i noise*)+
	{ return {
    	decrement: {
        	variable: v,
            multiple: t.length
        }
    }; }






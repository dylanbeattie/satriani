program     = p:statement *
                { return {program: p} }

comment     = '(' [^)]* ')'

_           = ((' ' / '\t')+) / comment

statement   = _* s:(operation / blank_line) ','? _* '\n'
                { return s }

operation   = output / assignment / expression

output      = ('say'i/'shout'i/'whisper'i/'scream'i) _+ e:expression
                {return {'output': e}}

simple_expression  =    pronoun / lookup / number / string

number      = n:$('-'?[0-9]+ ('.' [0-9]+)?)
                { return {number: parseFloat(n)} }

string      = '"' s:$[^"]+ '"'
                { return {string: s}}

blank_line  = _* {return {blank:  ''}}

expression  = sum

sum         = first:product rest:((add / subtract) product)+
                { return rest.reduce(function(memo, curr) {
                      return { binary: { op: curr[0], left: memo, right: curr[1]} };
                }, first); }
            / product

product     = first:simple_expression rest:((multiply / divide) simple_expression)+
                { return rest.reduce(function(memo, curr) {
                    return { binary: { op: curr[0], left: memo, right: curr[1]} };
                }, first); }
            / simple_expression

// Note that operator aliases explicitly include a trailing space,
// otherwise 'with' is a prefix code for 'without' and confuses the parser.
add 		= _* ('+' / 'plus ' / 'with ') _*       { return '+' }
subtract 	= _* ('-' / 'minus ' / 'without ') _*   { return '-' }
multiply 	= _* ('*' / 'times ' / 'of ') _*        { return '*' }
divide 		= _* ('/' / 'over ' / 'between ') _*    { return '/' }

pronoun = pronoun:(
    // Longest pronouns first to avoid prefix coding errors.
    // 4-letter pronouns
    'they'i / 'them'i
    // 3-letter pronouns
    / 'she'i / 'him'i / 'her'i / 'hir'i / 'zie'i / 'zir'i / 'xem'i / 'ver'i
    // 2-letter pronouns
    / 'ze'i / 've'i / 'xe'i / 'it'i / 'he'i
    )
    { return { pronoun: pronoun.toLowerCase() } }

lookup 	= v:variable
	{ return { lookup: { variable: v } }; }

common_prefix = ( 'an'i / 'a'i / 'the'i / 'my'i / 'your'i)
common_variable = prefix:common_prefix _+ name:$([A-Za-z]+)
				{ return (prefix + '_' + name).toLowerCase() };

assignment 	= v:variable _* ('=' / 'is 'i / 'was 'i) _* e:expression
				{ return { assign: { variable: v, expression: e} }; }

variable = common_variable / proper_variable

proper_noun = [A-Z][A-Za-z]*
proper_variable = head:$(proper_noun (' ' $proper_noun)*)
	{ return head.replace(/ /g, '_').toUpperCase()  }



